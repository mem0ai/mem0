---
title: Reranking
description: 'Improve memory search relevance with advanced reranking capabilities'
icon: "arrow-up-arrow-down"
iconType: "solid"
---

## Overview

Reranking is an advanced feature that improves the relevance of memory search results by re-ordering them based on more sophisticated relevance scoring. After initial vector similarity search, rerankers use specialized models to provide more accurate relevance scores.

<Note>
Reranking operates as a post-processing step after the initial vector search. It takes the top results from vector similarity search and re-scores them using more advanced models or custom logic.
</Note>

## How It Works

1. **Vector Search**: Initial semantic similarity search retrieves candidate memories
2. **Reranking**: Selected reranker re-scores candidates using advanced models  
3. **Final Results**: Re-ordered results with both vector and rerank scores

## Quick Start

Enable reranking by adding a `rerank` section to your memory configuration:

```python Python
from mem0 import Memory

config = {
    "vector_store": {
        "provider": "chroma",
        "config": {
            "collection_name": "my_memories",
            "path": "./chroma_db"
        }
    },
    "llm": {
        "provider": "openai", 
        "config": {
            "model": "gpt-4o-mini"
        }
    },
    "rerank": {
        "provider": "zero_entropy",
        "config": {
            "model": "zerank-1",
            "top_k": 5
        }
    }
}

memory = Memory.from_config(config)

# Add memories
messages = [
    {"role": "user", "content": "I love Italian pasta, especially carbonara"},
    {"role": "assistant", "content": "Carbonara is a classic Roman dish!"}
]

memory.add(messages, user_id="alice")

# Search with reranking - results automatically include rerank scores
results = memory.search("What Italian dishes does the user like?", user_id="alice")

for result in results['results']:
    print(f"Memory: {result['memory']}")
    print(f"Vector Score: {result['score']:.3f}")
    print(f"Rerank Score: {result['rerank_score']:.3f}")
```

## Supported Providers

Mem0 supports multiple reranking providers:

- **[Zero Entropy](../../components/rerankers/models/zero_entropy)**: State-of-the-art neural reranking
- **[Cohere](../../components/rerankers/models/cohere)**: Enterprise-grade with multilingual support
- **[Sentence Transformer](../../components/rerankers/models/sentence_transformer)**: Local HuggingFace models
- **[LLM-based](../../components/rerankers/models/llm)**: Custom scoring using any LLM

## When to Use Reranking

Reranking is particularly effective for:

- **Improved Relevance**: When vector search alone doesn't provide sufficiently relevant results
- **Domain-Specific Queries**: Specialized terminology or context that benefits from advanced models
- **Customer Support**: Finding the most relevant help articles and documentation
- **Knowledge Management**: Better search results in internal knowledge bases
- **Personal AI Assistants**: More accurate memory recall for user queries

## Configuration Options

Each reranker has specific configuration options. See the [Rerankers Documentation](../../components/rerankers/overview) for detailed configuration parameters.

### Basic Configuration

```python Python
"rerank": {
    "provider": "zero_entropy",  # or "cohere", "sentence_transformer", "llm"
    "config": {
        "top_k": 5,              # Limit results after reranking
        "api_key": "your-key"    # Provider-specific API key
    }
}
```

### Controlling Reranking

You can enable or disable reranking per search:

```python Python
# Search with reranking (default when configured)
results = memory.search("query", user_id="alice", rerank=True)

# Search without reranking
results = memory.search("query", user_id="alice", rerank=False)
```

## Performance Considerations

- **Latency**: Reranking adds processing time but significantly improves relevance
- **Cost**: API-based rerankers (Zero Entropy, Cohere, LLM) have per-request costs
- **Local Options**: Sentence Transformer reranker runs locally with no API costs
- **Quality vs Speed**: Balance based on your application's requirements

## Next Steps

- Explore specific [reranker providers](../../components/rerankers/overview) and their capabilities
- Learn about [configuration options](../../components/rerankers/config) for fine-tuning
- Check out [Vector Stores](../../components/vectordbs/overview) for different storage backends
- See [Async Memory](./async-memory) for non-blocking reranking operations